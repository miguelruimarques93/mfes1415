class PhysicalAccessControlSystem
types
	public User :: name: Utils`String
	inv mk_User(n) == len n > 0;
	
	public Facility :: name: Utils`String
	inv mk_Facility(n) == len n > 0;
	
	GroupUser = set of User;
	GroupFacility = set of Facility;
	
instance variables
	logFilename: Utils`String;
	io: IO := new IO();

	lastAccessCardId: nat := 0;
	lastAccessPointId: nat := 0;
	
	users: set of User := {};
	groupUsers: map Utils`String to GroupUser := {|->};
	
	facilities: set of Facility := {};
	groupFacilities: map Utils`String to GroupFacility := {|->};
	
	accessCards: set of AccessCard := {};
	accessPolicies: map AccessPoint to seq of AccessRule := {|->};
	
	accessCardUser: map AccessCard to User := {|->};
	
	inv dom accessCardUser subset accessCards;
	inv forall ac in set accessCards & forall ac1 in set accessCards \ {ac} & ac1.getID() <> ac.getID();
	inv rng accessCardUser subset users
	
operations

	public PhysicalAccessControlSystem: Utils`String ==> PhysicalAccessControlSystem
	PhysicalAccessControlSystem(filename) == (
		logFilename := filename;
		log("\n-- NEW LOG --");
		return self;
	);
	
	private log : Utils`String ==> ()
	log(val) == if not io.fecho(logFilename, val ^ "\n" , <append>) then IO`println("Error writing message to log file: " ^ val);

	public createNewAccessCard: () ==> AccessCard
	createNewAccessCard() == (
		lastAccessCardId := lastAccessCardId + 1;
		let ac: AccessCard = new AccessCard(lastAccessCardId) in (
			accessCards := accessCards union {ac};
			return ac;
		);
	);
	
	public createNewTemporaryAccessCard: Date ==> AccessCard
	createNewTemporaryAccessCard(expDate) == (
		let newCard: AccessCard = createNewAccessCard() in (
			newCard.setExpirationDate(expDate);
			return newCard;
		);
	);
	
	public createNewUser : Utils`String ==> User
	createNewUser(name) == (
		let user = mk_User(name) in (
			groupUsers := groupUsers munion { name |-> { user } };
			users := users union {user};
			return user;
		);
	)
	pre let u = mk_User(name) in u not in set users;
	
	public associateAccessCardToUser: AccessCard * User ==> ()
	associateAccessCardToUser(ac, user) == (
		accessCardUser := accessCardUser munion { ac |-> user };
	) pre user not in set rng accessCardUser and 
				ac not in set dom accessCardUser;
	
	public removeUserAccessCard: User ==> ()
	removeUserAccessCard(user) == (
		accessCardUser := accessCardUser :-> { user };
	) pre user in set rng accessCardUser;
	
	public transferUserAccessCard: User * User ==> ()
	transferUserAccessCard(source, destination) == (
		let ac: AccessCard = (inverse accessCardUser)(source) in (
			removeUserAccessCard(source);
			associateAccessCardToUser(ac, destination);
		);	
	);
	
	public createNewGroupOfUsers : Utils`String ==> ()
	createNewGroupOfUsers(name) == (
		groupUsers := groupUsers munion { name |-> { } };
	)
	pre not name in set dom groupUsers;
	
	public addUserToGroupOfUsers : Utils`String * User ==> ()
	addUserToGroupOfUsers(groupName, user) == (
		groupUsers(groupName) := groupUsers(groupName) union { user };
	)
	pre groupName in set dom groupUsers 
	and user in set users;

	public createNewFacility: Utils`String ==> Facility
	createNewFacility(name) == (
		let fac = mk_Facility(name) in (
			groupFacilities := groupFacilities munion { name |-> { fac } };
			facilities := facilities union { fac };
			return fac
		);
	)
	pre let f = mk_Facility(name) in f not in set facilities;
	
	public createNewAccessPoint: Facility ==> AccessPoint
	createNewAccessPoint(fac) == (
		lastAccessPointId := lastAccessPointId + 1;
		let ap: AccessPoint = new AccessPoint(lastAccessPointId, fac) in (
			accessPolicies := accessPolicies munion { ap |-> [ ] };
			return ap;
		);
	)
	pre fac in set facilities;
	
	public addAccessRuleToAccessPoint: AccessPoint * AccessRule ==> ()
	addAccessRuleToAccessPoint(ap, ar) == (
		accessPolicies(ap) := accessPolicies(ap) ^ [ ar ] 
	)
	pre ar.groupUser in set dom groupUsers and ar.groupFacility in set dom groupFacilities; 

	private requestAccessImpl : AccessCard * AccessPoint * Date ==> (bool * Utils`String * Utils`String)
	requestAccessImpl(ac, accessPoint, date) == (
		if not ac in set dom accessCardUser then return mk_(false, "Uknown user", "access card is not associated with a user");
		if not ac.isValid(date) then return mk_(false, accessCardUser(ac).name, "access card expired");
		
		let user: User = accessCardUser(ac),
			  rules: seq of AccessRule = accessPolicies(accessPoint),
			  validIndices: set of nat1 = { i | 
					i in set inds rules & 
						rules(i).isValid(date) and
						user in set groupUsers(rules(i).getGroupUser()) and 
						accessPoint.getFacility() in set groupFacilities(rules(i).getGroupFacility()) 
				} in 
		(
			if card validIndices = 0 or rules(Utils`max(validIndices)).getRuleType() = <deny>
			then return mk_(false, user.name, "user is not authorized")
			else return mk_(true, user.name, "")
		)
	);
	
	public requestAccess : AccessCard * AccessPoint * Date ==> bool
	requestAccess(ac, accessPoint, date) == (
		let result = requestAccessImpl(ac, accessPoint, date) in (
			if result.#1
			then log("Access granted to " ^ accessPoint.getFacility().name ^ " for " ^ result.#2 ^ ".") -- TODO add datetime
			else log("Access denied to " ^ accessPoint.getFacility().name ^ " for " ^ result.#2 ^ ": " ^ result.#3 ^ ".");  -- TODO add datetime
			
			return result.#1;
		);
	);
		
end PhysicalAccessControlSystem