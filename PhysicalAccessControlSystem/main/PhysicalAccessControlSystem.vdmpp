class PhysicalAccessControlSystem
types
	public User :: name: Utils`String
	inv mk_User(n) == len n > 0;
	
	public Facility :: name: Utils`String
	inv mk_Facility(n) == len n > 0;
	
	GroupUser = set of User;
	GroupFacility = set of Facility;
	
instance variables
	lastAccessCardId: nat := 0;
	lastAccessPointId: nat := 0;
	
	users: set of User := {};
	groupUsers: map Utils`String to GroupUser := {|->};
	
	facilities: set of Facility := {};
	groupFacilities: map Utils`String to GroupFacility := {|->};
	
	accessCards: set of AccessCard := {};
	accessPolicies: map AccessPoint to set of AccessRule := {|->};
	
	userAccessCard: map User to AccessCard := {|->};
	
	inv let us = getUsers() in ( forall user in set dom userAccessCard & user in set us );
	inv rng userAccessCard subset accessCards;
	inv forall ac in set accessCards & forall ac1 in set accessCards \ {ac} & ac1.getID() <> ac.getID();
	inv dom userAccessCard subset users
	
operations

	public createNewAccessCard: () ==> AccessCard
	createNewAccessCard() == (
		lastAccessCardId := lastAccessCardId + 1;
		let ac: AccessCard = new AccessCard(lastAccessCardId) in (
			accessCards := accessCards union {ac};
			return ac;
		);
	);
	
	public createNewTemporaryAccessCard: Date ==> AccessCard
	createNewTemporaryAccessCard(expDate) == (
		let newCard: AccessCard = createNewAccessCard() in (
			newCard.setExpirationDate(expDate);
			return newCard;
		);
	);
	
	public createNewUser : Utils`String ==> User
	createNewUser(name) == (
		let user = mk_User(name) in (
			groupUsers := groupUsers munion { name |-> { user } };
			users := users union {user};
			return user;
		);
	)
	pre let u = mk_User(name) in u not in set users;
	
	public createNewGroupOfUsers : Utils`String ==> ()
	createNewGroupOfUsers(name) == (
		groupUsers := groupUsers munion { name |-> { } };
	)
	pre not name in set dom groupUsers;
	
	public addUserToGroupOfUsers : Utils`String * User ==> ()
	addUserToGroupOfUsers(groupName, user) == (
		groupUsers(groupName) := groupUsers(groupName) union { user };
	)
	pre groupName in set dom groupUsers 
	and user in set users;

	public createNewFacility: Utils`String ==> Facility
	createNewFacility(name) == (
		let fac = mk_Facility(name) in (
			groupFacilities := groupFacilities munion { name |-> { fac } };
			facilities := facilities union { fac };
			return fac
		);
	)
	pre let f = mk_Facility(name) in f not in set facilities;
	
	public createNewAccessPoint: Facility ==> AccessPoint
	createNewAccessPoint(fac) == (
		lastAccessPointId := lastAccessPointId + 1;
		let ap: AccessPoint = new AccessPoint(lastAccessPointId, fac) in (
			accessPolicies := accessPolicies munion { ap |-> { } };
			return ap;
		);
	)
	pre fac in set facilities;
	
	public addAccessRuleToAccessPolicy: AccessPoint * AccessRule ==> ()
	addAccessRuleToAccessPolicy(ap, ar) == (
		accessPolicies(ap) := accessPolicies(ap) union { ar } 
	);


	private getUsers : () ==> set of User
	getUsers() == return users;	
end PhysicalAccessControlSystem