class PhysicalAccessControlSystem
types
	public User :: name: Utils`String
	inv mk_User(n) == len n > 0;
	
	public Facility :: name: Utils`String
	inv mk_Facility(n) == len n > 0;
	
	GroupUser = set of User;
	GroupFacility = set of Facility;
	
instance variables
	logFilename: Utils`String;
	io: IO := new IO();

	lastAccessCardId: nat := 0;
	lastAccessPointId: nat := 0;
	
	users: set of User := {};
	groupUsers: map Utils`String to GroupUser := {|->};
	
	facilities: set of Facility := {};
	groupFacilities: map Utils`String to GroupFacility := {|->};
	
	accessCards: set of AccessCard := {};
	accessPolicies: map AccessPoint to seq of AccessRule := {|->};
	
	accessCardUser: map AccessCard to User := {|->};
	
	inv dom accessCardUser subset accessCards;
	inv forall ac in set accessCards & forall ac1 in set accessCards \ {ac} & ac1.getID() <> ac.getID();
	inv rng accessCardUser subset users
	
operations

	public PhysicalAccessControlSystem: Utils`String ==> PhysicalAccessControlSystem
	PhysicalAccessControlSystem(filename) == (
		logFilename := filename;
		log("\n-- NEW LOG --");
		return self;
	);
	
	private log : Utils`String ==> ()
	log(val) == if not io.fecho(logFilename, val ^ "\n" , <append>) then IO`println("Error writing message to log file: " ^ val);

	public createNewAccessCard: () ==> AccessCard
	createNewAccessCard() == (
		lastAccessCardId := lastAccessCardId + 1;
		let ac: AccessCard = new AccessCard(lastAccessCardId) in (
			accessCards := accessCards union {ac};
			return ac;
		);
	);
	
	public createNewTemporaryAccessCard: DateTime ==> AccessCard
	createNewTemporaryAccessCard(expDate) == (
		let newCard: AccessCard = createNewAccessCard() in (
			newCard.setExpirationDate(expDate);
			return newCard;
		);
	);
	
	public removeAccessCard: AccessCard ==> ()
	removeAccessCard(ac) == (
		accessCards := accessCards \ { ac };
		accessCardUser := { ac } <-: accessCardUser;
	)
	pre ac in set accessCards
	post not ac in set accessCards and
			 not ac in set dom accessCardUser;
	
	public createNewUser : Utils`String ==> User
	createNewUser(name) == (
		let user = mk_User(name) in (
			groupUsers := groupUsers munion { name |-> { user } };
			users := users union {user};
			return user;
		);
	)
	pre let u = mk_User(name) in u not in set users;
	
	public removeUser: User ==> ()
	removeUser(user) == (
		users := users \ { user };
		for all groupName in set dom groupUsers do (
			groupUsers(groupName) := groupUsers(groupName) \ { user }; 
		);
		groupUsers := { user.name } <-: groupUsers;
		accessCardUser := accessCardUser :-> { user };
		for all ap in set dom accessPolicies do (
			accessPolicies(ap) := [accessPolicies(ap)(i) | i in set inds accessPolicies(ap) & accessPolicies(ap)(i).groupUser <> user.name]
		);
	)
	pre user in set users
	post not user in set users and
			 not user in set rng accessCardUser and
			 not user in set dunion rng groupUsers;
	
	public associateAccessCardToUser: AccessCard * User ==> ()
	associateAccessCardToUser(ac, user) == (
		accessCardUser := accessCardUser munion { ac |-> user };
	) pre user not in set rng accessCardUser and 
				ac not in set dom accessCardUser;
	
	public removeUserAccessCard: User ==> ()
	removeUserAccessCard(user) == (
		accessCardUser := accessCardUser :-> { user };
	) pre user in set rng accessCardUser;
	
	public transferUserAccessCard: User * User ==> ()
	transferUserAccessCard(source, destination) == (
		let ac: AccessCard = (inverse accessCardUser)(source) in (
			removeUserAccessCard(source);
			associateAccessCardToUser(ac, destination);
		);	
	);
	
	public createNewGroupOfUsers : Utils`String ==> ()
	createNewGroupOfUsers(name) == (
		groupUsers := groupUsers munion { name |-> { } };
	)
	pre not name in set dom groupUsers
	post name in set dom groupUsers;
	
	public removeGroupOfUsers : Utils`String ==> ()
	removeGroupOfUsers(name) == (
		groupUsers := { name } <-: groupUsers;
		for all ap in set dom accessPolicies do (
			accessPolicies(ap) := [accessPolicies(ap)(i) | i in set inds accessPolicies(ap) & accessPolicies(ap)(i).groupUser <> name]
		);
	)
	pre name in set dom groupUsers
	post not name in set dom groupUsers;
	
	public addUserToGroupOfUsers : Utils`String * User ==> ()
	addUserToGroupOfUsers(groupName, user) == (
		groupUsers(groupName) := groupUsers(groupName) union { user };
	)
	pre groupName in set dom groupUsers 
	and user in set users
	post user in set groupUsers(groupName);
	
	public removeUserFromGroupOfUsers : Utils`String * User ==> ()
	removeUserFromGroupOfUsers(groupName, user) == (
		groupUsers(groupName) := groupUsers(groupName) \ { user };
	)
	pre groupName in set dom groupUsers and
			user in set groupUsers(groupName)
	post groupName in set dom groupUsers => not user in set groupUsers(groupName);

	public createNewFacility: Utils`String ==> Facility
	createNewFacility(name) == (
		let fac = mk_Facility(name) in (
			groupFacilities := groupFacilities munion { name |-> { fac } };
			facilities := facilities union { fac };
			return fac
		);
	)
	pre let f = mk_Facility(name) in f not in set facilities;
	
	public removeFacility: Facility ==> ()
	removeFacility(fac) == (
		facilities := facilities \ { fac };
		for all groupName in set dom groupFacilities do (
			groupFacilities(groupName) := groupFacilities(groupName) \ { fac }; 
		);
		groupFacilities := { fac.name } <-: groupFacilities;
		accessPolicies := { ap | ap in set dom accessPolicies & ap.facility <> fac } <-: accessPolicies;
		for all ap in set dom accessPolicies do (
			accessPolicies(ap) := [accessPolicies(ap)(i) | i in set inds accessPolicies(ap) & accessPolicies(ap)(i).groupFacility <> fac.name]
		);
	)
	pre fac in set facilities
	post not fac in set facilities and
			 not fac in set { ap.facility | ap in set dom accessPolicies } and
			 not fac in set dunion rng groupFacilities;
	
	public createNewGroupOfFacilities : Utils`String ==> ()
	createNewGroupOfFacilities(name) == (
		groupFacilities := groupFacilities munion { name |-> { } };
	)
	pre not name in set dom groupFacilities;
	
	public removeGroupOfFacilities : Utils`String ==> ()
	removeGroupOfFacilities(name) == (
		groupFacilities := { name } <-: groupFacilities;
		for all ap in set dom accessPolicies do (
			accessPolicies(ap) := [accessPolicies(ap)(i) | i in set inds accessPolicies(ap) & accessPolicies(ap)(i).groupFacility <> name]
		);
	)
	pre name in set dom groupFacilities
	post not name in set dom groupFacilities;
	
	public addFacilityToGroupOfFacilities : Utils`String * Facility ==> ()
	addFacilityToGroupOfFacilities(groupName, fac) == (
		groupFacilities(groupName) := groupFacilities(groupName) union { fac };
	)
	pre groupName in set dom groupFacilities and 
			fac in set facilities;
			
	public removeFacilityFromGroup : Utils`String * Facility ==> ()
	removeFacilityFromGroup(groupName, fac) == (
		groupFacilities(groupName) := groupFacilities(groupName) \ { fac };
	)
	pre groupName in set dom groupFacilities and 
			fac in set facilities and
			fac in set groupFacilities(groupName)
	post groupName in set dom groupFacilities => not fac in set groupFacilities(groupName);
	
	public createNewAccessPoint: Facility ==> AccessPoint
	createNewAccessPoint(fac) == (
		lastAccessPointId := lastAccessPointId + 1;
		let ap: AccessPoint = new AccessPoint(lastAccessPointId, fac) in (
			accessPolicies := accessPolicies munion { ap |-> [ ] };
			return ap;
		);
	)
	pre fac in set facilities;
	
	public removeAccessPoint: AccessPoint ==> ()
	removeAccessPoint(ap) == (
		accessPolicies := { ap } <-: accessPolicies;
	)
	pre ap in set dom accessPolicies
	post not ap in set dom accessPolicies;
	
	public addAccessRuleToAccessPoint: AccessPoint * AccessRule ==> ()
	addAccessRuleToAccessPoint(ap, ar) == (
		accessPolicies(ap) := accessPolicies(ap) ^ [ ar ] 
	)
	pre ar.groupUser in set dom groupUsers and ar.groupFacility in set dom groupFacilities; 

	private requestAccessImpl : AccessCard * AccessPoint * DateTime ==> (bool * Utils`String * Utils`String)
	requestAccessImpl(ac, accessPoint, date) == (
		if not ac in set dom accessCardUser then return mk_(false, "Uknown user", "access card is not associated with a user");
		if not ac.isValid(date) then return mk_(false, accessCardUser(ac).name, "access card expired");
		
		let user: User = accessCardUser(ac),
			  rules: seq of AccessRule = accessPolicies(accessPoint),
			  validIndices: set of nat1 = { i | 
					i in set inds rules & 
						rules(i).isValid(date) and
						user in set groupUsers(rules(i).getGroupUser()) and 
						accessPoint.getFacility() in set groupFacilities(rules(i).getGroupFacility()) 
				} in 
		(
			if card validIndices = 0 or rules(Utils`max(validIndices)).getRuleType() = <deny>
			then return mk_(false, user.name, "user is not authorized")
			else return mk_(true, user.name, "")
		)
	);
	
	public requestAccess : AccessCard * AccessPoint * DateTime ==> bool
	requestAccess(ac, accessPoint, date) == (
		let result = requestAccessImpl(ac, accessPoint, date) in (
			if result.#1
			then log(date.toString() ^ ": Access granted to " ^ accessPoint.getFacility().name ^ " for " ^ result.#2 ^ ".") -- TODO add datetime
			else log(date.toString() ^ ": Access denied to " ^ accessPoint.getFacility().name ^ " for " ^ result.#2 ^ ": " ^ result.#3 ^ ".");  -- TODO add datetime
			
			return result.#1;
		);
	);
		
end PhysicalAccessControlSystem